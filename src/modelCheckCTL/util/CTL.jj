/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CTL.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(eg1)package modelCheckCTL.util;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

public class eg1/*@bgen(jjtree)*/implements eg1TreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTeg1State jjtree = new JJTeg1State();

/*@egen*/  public static void main(String args []) throws ParseException  {
    InputStreamReader converter = new InputStreamReader(System.in);
	BufferedReader in = new BufferedReader(converter);
    InputStream stream = new ByteArrayInputStream(new byte[0]);    eg1 parser = new eg1(stream);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"AF(!p)\" :");      try      {
        stream = new ByteArrayInputStream(in.readLine().getBytes());
        parser.ReInit(stream);
        ASTFormula f = parser.Formula();
        f.dump("");      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());
        e.printStackTrace();      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(eg1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :
{
  < NOT : "!" >
}
TOKEN :
{  < AND : "&&" >
| < OR : "||" >
}
TOKEN :
{  < THEN : "->" >
}TOKEN :{  < ALL : "A" >| < EXISTS : "E" >}TOKEN :
{
  < FUTURE : "F" >
| < GLOBALY : "G" >
| < NEXT : "X" >
| < UNTIL : "U" >
}TOKEN :{  < ATOM : ["a"-"z"](["a"-"z","0"-"9"])* >}
ASTFormula Formula():
{/*@bgen(jjtree) Formula */
  ASTFormula jjtn000 = new ASTFormula(JJTFORMULA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Formula */
  try {
/*@egen*/  Phi()< EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void Phi()       :{}
{    Atom()
| "(" expr() ")"
| Connective() 
}
void expr()      :
{/*@bgen(jjtree) Expr */
 ASTExpr jjtn000 = new ASTExpr(JJTEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Node n; int result=-1;}
{/*@bgen(jjtree) Expr */
  try {
/*@egen*/  result=< NOT >.kind Phi()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(result); }
| Phi() result=exprPrime2() Phi()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(result); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
int exprPrime2()      :
{Token t;}
{  t=< AND >  {return t.kind;}
| t=< OR >
  {return t.kind;}
| t=< THEN >
  {return t.kind;}
}
void exprPrime()      :
{}
{
  < AND > Phi()
| < OR > Phi()
| < THEN > Phi()
}
void Connective()            :
{/*@bgen(jjtree) Connective */
 ASTConnective jjtn000 = new ASTConnective(JJTCONNECTIVE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/int path, temporal;}
{/*@bgen(jjtree) Connective */
  try {
/*@egen*/
  (  path=< ALL >.kind temporal=connPart2()
| path=< EXISTS >.kind temporal=connPart2()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(path, temporal); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
int connPart2()      :
{int kind;}
{  (    kind=< NEXT >.kind Phi()
| kind=< FUTURE >.kind Phi()
| kind=< GLOBALY >.kind Phi()
| "[" Phi() kind=< UNTIL >.kind Phi() "]"
  )
  { return kind; }
}

void Atom()      :
{/*@bgen(jjtree) Atom */
 ASTAtom jjtn000 = new ASTAtom(JJTATOM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Atom */
  try {
/*@egen*/  t=< ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {	jjtn000.setName(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}












